package org.usfirst.frc.team5141.robot; 

import edu.wpi.first.wpilibj.IterativeRobot;
//import edu.wpi.cscore.UsbCamera;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.GenericHID;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.SerialPort;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.VictorSP;
import edu.wpi.first.wpilibj.Spark;
import com.kauailabs.navx.frc.AHRS;
import com.kauailabs.navx.frc.AHRS.SerialDataType;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */

public class Robot extends IterativeRobot {
private static final String kDefaultAuto = "Default";
private static final String kCustomAuto = "My Auto";
private SendableChooser<String> m_chooser = new SendableChooser<>();
DriverStation ds = DriverStation.getInstance();
AHRS ahrs;
Servo servo = new Servo(4);
Joystick gamePad0 = new Joystick (0);
Joystick gamePad1 = new Joystick (1);
// double leftStickY = gamePad0.getRawAxis(1);
// double rightStickY = gamePad0.getRawAxis(5);
// VictorSP leftOne = new VictorSP(0);
VictorSP leftTwo = new VictorSP(1);
// VictorSP leftThree = new VictorSP(2);
// SpeedControllerGroup leftDrive = new SpeedControllerGroup(leftOne, leftTwo, leftThree);
SpeedControllerGroup leftDrive = new SpeedControllerGroup(leftTwo);
// VictorSP rightOne = new VictorSP(3);
VictorSP rightTwo = new VictorSP(7);
// VictorSP rightThree = new VictorSP(5);
// SpeedControllerGroup rightDrive = new SpeedControllerGroup(rightOne, rightTwo, rightThree);
SpeedControllerGroup rightDrive = new SpeedControllerGroup(rightTwo);
VictorSP elevator = new VictorSP(9);
VictorSP intakeLeft = new VictorSP(6);
VictorSP intakeRight = new VictorSP(5);
SpeedControllerGroup intakeBoth = new SpeedControllerGroup(intakeLeft, intakeRight);
VictorSP climber = new VictorSP(3); //
VictorSP climbLift = new VictorSP(0); //the motor that extends the hook up
Spark rgbLights = new Spark(2); //the Blinkin
DifferentialDrive driveTrain = new DifferentialDrive(leftDrive, rightDrive);
boolean confirmPath = false;
// Compressor c = new Compressor(0);
// Solenoid s0 = new Solenoid(0);
// Solenoid s1 = new Solenoid(1);
// Solenoid s2 = new Solenoid(2);
/**If we had encoder code, again
* Encoder enc;
* enc = new Encoder(0, 1, false, Encoder.EncodingType.k4X);
* 
* 
* enc.setMaxPeriod(.1);
* Max Period: The maximum period (in seconds) where the device is still considered moving.
* 
* enc.setMinRate(10);
* Min Rate: Sets the minimum rate before the device is considered stopped.
* 
* enc.setDistancePerPulse(5);
* Distance Per Pulse: Sets the scale factor between pulses and distance.
* 12334567
* enc.setReverseDirection(true);
* Reverse Direction: Sets the direction the encoder counts, used to flip the direction if the encoder mounting makes the default counting direction unintuitive.
* 
* enc.setSamplesToAverage(7);
* Sets the number of samples to average when determining the period.
* 
* Resetting the Encoder
* 
* enc.reset();
* 
* Getting Encoder Values
* 
* int count = enc.get();
* Count: The current count. May be reset by calling reset().
* 
* double rawCount = enc.getRaw();
* Raw Count: The count without compensation for decoding scale factor.
* 
* double distance = enc.getDistance();
* Distance: The current distance reading from the counter. This is the count multiplied by the Distance Per Count scale factor.
* 
* double period = enc.getPeriod();
* Period: The current period of the counter in seconds. DEPRECATED USE RATE
* 
* double rate = enc.getRate();
* Rate: The current rate of the counter in units/sec.  It is calculated using the DistancePerPulse divided by the period.
* 
* boolean direction = enc.getDirection();
* Direction: The direction of the last value change (true for Up, false for Down).
* 
* boolean stopped = enc.getStopped();
* Stopped: If the counter is currently stopped (period has exceeded Max Period).
* 
* 
*/
int autoLoopCounter;
int toggCount, toggCount1, toggCount2;
boolean toggCount3;
int toggIntake1 = 0;
int toggIntake2 = 0;
boolean adjustCube;
int elevatorState; //Level Elevator is Physically At
int elevatorDestiny; //Level Elevator Wants To Go
String elevatorMode = "automatic"; 
boolean elevatorTransition;
double drive;
double red = .61 ;
double blue = .87;
double gold = .67;
boolean cToggCount = false;
boolean cToggCount1 = false;
boolean cToggCount2 = false;
static double ERROR=0.5; //acceptable error for "t:" case. It will stop turning once it's within this amount of the target angle, basically.
int i;
boolean done;
final int DIRECTION=-1;
final double TURNTIME=1.5;
final double MAX_NOTHING_SPEED_LEFT=0.3;
final double MAX_NOTHING_SPEED_RIGHT=0.3;
final double MAX_GOOD_SPEED=.15;
final double MAX_NOTHING_ANGLE_SPEED_LEFT=.45;
final double MAX_NOTHING_ANGLE_SPEED_RIGHT=.45;
final double MAX_GOOD_ANGLE_SPEED=0.55; //this should be 1-.45 maximum (0.55)
final double PROPORTION_LEFT=1;
final double PROPORTION_RIGHT=1;
final double RETRY_PROPORTION=2.5; //every time it goes past target angle, it divides the error by this number, so that decreases the speed. the higher the speed, the higher this number should be.
final double RETRY_ATTEMPTS=3; //it will pass the target angle at least this many times ("unless it doesn't"), then won't stop until acceptable error is achieved.
final int INTAKE_DIRECTION=1;
double timeStart=0;
double angleStart=0;
double encoderStart=0;
double g=0;
int toggle=0;
int toggleR2=0;
int toggleL2=0;
int toggleDont=0;
double percentError2=0;
int percentErrorPassCounter=0;
double startAngle;
double encRateToTankRate=DIRECTION*45/100.0;
double BUFFER_DISTANCE=3;
double distanceInchesL;
double distanceInchesR;
double targetAngle = 0;
double targetTurnAmount;
DigitalInput limitSwitch0 = new DigitalInput(2); //elevator at ground level
DigitalInput limitSwitch1 = new DigitalInput(3); //elevator at switch level
DigitalInput limitSwitch2 = new DigitalInput(4); //elevator at low scale level
DigitalInput limitSwitch3 = new DigitalInput(5); //elevator at high scale level
DigitalInput limitSwitch4 = new DigitalInput(1); //climberHook fully extended
DigitalInput limitSwitch5 = new DigitalInput(0); //climberLift has climbed the bot to top
Timer timer = new Timer();
Timer elevatorTimer = new Timer();
Encoder encLeft = new Encoder(6, 7);
Encoder encRight = new Encoder(8, 9);
/*GAME DEPENDENT VARIABLES ****************************************************************************************************************************
*********************************** llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll*******************************************************************************************************************
**************************************************************************************************************************************goblin**********
*/
char startPosition = 'L';
  //If you place the bot on the left, type 'L' here; center, 'C'; right, 'R'
char switchPosition;                              //HOW DOES GAMEDATA WORK?! AGGHHHHH!!! 3/14/2018 4:34 PM ED
char scalePosition;
String destination = "Sw";  //If you're going for the switch, type "Sw"; scale, "Sc"
/*****************************************************************************************************************************************************
*****************************************************************************************************************************************************
*/
GenericHID.RumbleType rumble(double Output) { 
return null;
}
// public boolean solenoidAll(boolean aBoolean) {
// s0.set(aBoolean);
// s1.set(aBoolean);
// s2.set(aBoolean);
// return false;
// }
    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    public void robotInit() {
    System.out.println("--- robotinit");
   
   
    m_chooser.addDefault("Default Auto", kDefaultAuto);
m_chooser.addObject("My Auto", kCustomAuto);
SmartDashboard.putData("Auto choices", m_chooser);
    leftDrive.setInverted(true);
    rightDrive.setInverted(true);
    intakeRight.setInverted(true);
    elevator.setInverted(false);
//    UsbCamera camera = new UsbCamera("cam0",0);
//    camera.setFPS(15);
    CameraServer.getInstance().startAutomaticCapture();
    ahrs = new AHRS(SerialPort.Port.kMXP, SerialDataType.kProcessedData, (byte)50);
    rgbLights.set(0.13);
    encLeft.setDistancePerPulse(12/918.0); //This converts encoder pulses to inches.
    encRight.setDistancePerPulse(12/918.0);//12
    }
    
    
    
    public String sameTurnary(char position) {
    String value = "t:"+(position == 'L' ? "90" : "-90");
    return value;
    }
   
    public String differentTurnary(char position) {
    String value = "t:"+(position == 'L' ? "-90" : "90");
    return value;
    }
    
    /**
     * This function is run once each time the robot enters autonomous mode
     */
    final String[] COMMANDLIST={
//    "e:2","w:.1","e:0"
//    "e:2"
//    "j:0","b:120"
//    "j:0","g:1","d:2","g:0","t:180","d:1"
};
 /*   final String[] COMMANDLIST_S_SW= {
//    "j:0","b"
    "j:0","g:1","w:.5","g:0","b:120","g:1","e:2",sameTurnary(switchPosition),"g:0","b:6","g:-1","w:1","g:0"
//    "j:0","g:1","w:.5","g:0","b:2","g:1","e:2",sameTurnary(switchPosition),"g:0","b:0.5","g:-1","w:1","g:0"
    };
    */
    final String[] COMMANDLIST_L_SW_L= {
//    "e:2","w:.2","e:0"
    "j:0","j:0","e:2","w:.2","e:0","g:1","w:.5","g:0","b:120","g:1","e:2","t:90","g:0","b:6","g:-1","w:1","g:0"
    };
    final String[] COMMANDLIST_R_SW_R= {
    "j:0","j:0","e:2","w:.2","e:0","g:1","w:.5","g:0","b:120","g:1","e:2","t:-90","g:0","b:6","g:-1","w:1","g:0"
    };
/*   final String[] COMMANDLIST_D_SW = {
//    "j:0","b:120"
    "j:0","g:1","w:.5","g:0","b:200",differentTurnary(switchPosition),"b:145",differentTurnary(switchPosition),"e:6","w:3","b:18","g:-1","w:1","g:0"
//  "j:0","g:1","w:.5","g:0","b:3",sameTurnary(switchPosition),"b:2",sameTurnary(switchPosition),"e:6","w:3","b:0.5","g:-1","w:1","g:0"
    };
    */
    final String[] COMMANDLIST_L_SW_R = {
    "j:0","j:0","e:2","w:.2","e:0","g:1","w:.5","g:0","b:220","t:90","b:155","t:90","e:4","w:3","b:18","g:-1","w:1","g:0"
    };
    final String[] COMMANDLIST_R_SW_L = {
    "j:0","j:0","e:2","w:.2","e:0","g:1","w:.5","g:0","b:220","t:-90","b:155","t:-90","e:4","w:3","b:18","g:-1","w:1","g:0"
    };
    final String[] COMMANDLIST_C = {
    "j:0","j:0","e:2","w:.2","e:0","g:1","w:.2","g:0","e:2","b:100","g:-1"
    };
//    final String[] COMMMANDLIST_C_SW_L = {
//    "j:0","j:0","e:2","w:.2","e:0","g:1","w:.2","g:0","b:60","t:-90","b:84","t:90","b:50"
//    };
    
    final String[] COMMANDLIST_S_SC = {
//    "j:0","b:120"
//    "j:0","g:1","w:.5","g:0","b:500","e:4","w:3",sameTurnary(switchPosition),"b:1","g:-1"
    };
    final String[] COMMANDLIST_D_SC = {
//    "j:0","b:120"
//    "j:0","g:1","w:.5","g:0","b:270",sameTurnary(scalePosition),"b:170",differentTurnary(scalePosition),"b:12","e:6","w:3",differentTurnary(scalePosition),"g:-1","w:.5","g:0"
    };
    
    //^This needs testing, maybe it will work great? 3/15 11:02 AM ED
    
    public void autonomousInit() {
   
    System.out.println("--- autoinit");

    timer.reset();
    timer.start();
    elevatorDestiny=0;
//    c.setClosedLoopControl(false);
    rgbLights.set(0.13);
    ahrs.reset();
    String gameData="s";
//    do {
//    gameData = DriverStation.getInstance().getGameSpecificMessage();
//    }while(gameData.length()!=3);
   
    while(gameData.length()<3) {gameData = DriverStation.getInstance().getGameSpecificMessage();}
    switchPosition = gameData.charAt(0);
    scalePosition = gameData.charAt(1);
    /*
    * Operations:
    * d=drive unit seconds
    * t=turn unit degrees from -180 to 180
    */
    done=false;
    i=0;
    commandRunner("r:0");
   
    
    }
    
    public boolean commandRunner(String command) {
    SmartDashboard.putNumber("Rate", DIRECTION*encLeft.getRate());
    double yaw=DIRECTION*ahrs.getYaw();
    //cuts below ;
        char operation=command.substring(0,command.indexOf(":")).charAt(0);
        //cuts after
        double value=Double.valueOf(command.substring(command.indexOf(":")+1));
    switch(operation) {
    case 's'://stop
    driveTrain.stopMotor();
    driveTrain.tankDrive(-0.45*Math.signum(value)*DIRECTION,-0.45*Math.signum(value)*DIRECTION);//Stops Robot by driving in direction of value 
    //driveTrain.tankDrive(-encLeft.getRate()*encRateToTankRate,-encLeft.getRate()*encRateToTankRate);
    return encLeft.getRate()<ERROR;
    case 'g':   //grab
    g=Math.signum(value)*.5;
    intakeBoth.set(g);//suck in direction of value
    return true;
    case 'w': // wait
    if(timeStart==0) {
    timeStart=timer.get();//set timer to 0 
    }
    else {
    if(timer.get()-timeStart>=value) {
    commandRunner("r:0");//if done reset
    return true;
    }
    }
    break;
    case 'c':
    if (toggle ==0) {
    servo.setAngle(value);//turn
    toggle=1;
    }
    else {
    boolean maybe=commandRunner("w:"+String.valueOf(TURNTIME));//wait till done
    toggle=1;
    if (maybe||servo.getSpeed()==0) {
    commandRunner("r:0");
    return true;
    }
    }
    break;
    case 'r': //reset
    timeStart=0;
    angleStart=0;
    toggle=0;
    percentError2=0;
    percentErrorPassCounter=0;
    yaw=0;
    encoderStart=0;
    distanceInchesL=0;
    encLeft.reset();
    return true;
    case 'e': //set elevator
    elevatorDestiny=(int) value;
    elevatorTransition=true;
    return true;
    case 'j': // jolt
    if(toggle==0) {
    timeStart=timer.get();
    //encoderStart=enc.getDistance();
    toggle=1;
    }
    else {
    if(timer.get()-timeStart<.19) {
      driveTrain.tankDrive(DIRECTION*.67,DIRECTION*.67);
   
    }
    else if(timer.get()-timeStart<.21) {
    driveTrain.tankDrive(0,0);
    }
    else if(timer.get()-timeStart<.49725) {
      driveTrain.tankDrive(-DIRECTION*.67,-DIRECTION*.67);
   
    }
    else {
    driveTrain.tankDrive(0, 0);
    commandRunner("r:0");
    return true;
    }
        }
    break;
   
    case 'd': //drive
    if(toggle==0) {
    timeStart=timer.get();
    //encoderStart=enc.getDistance();
    toggle=1;
    }
    else {
    if(timer.get()-timeStart<Math.abs(value)) {
    //double drive=MAX_GOOD_SPEED*DIRECTION;
      driveTrain.tankDrive(Math.signum(value)*(DIRECTION*MAX_NOTHING_SPEED_LEFT+.1),Math.signum(value)*(DIRECTION*MAX_NOTHING_ANGLE_SPEED_RIGHT+.1));
   
    }
    /*
    * if(enc.getDistance()-ancoderStart<value-ERROR)
    * {
    * double drive=MAX_GOOD_SPEED*DIRECTION;
      driveTrain.tankDrive(drive+DIRECTION*MAX_NOTHING_SPEED_LEFT,drive+DIRECTION*MAX_NOTHING_SPEED_RIGHT);
      double rate=enc.getRate()
      SmartDashboard.putNumber("Rate left", rate);
    * }
    */
    else {
    driveTrain.tankDrive(0, 0);
    commandRunner("r:0");
    return true;
    }
        }
    break;

    case 'b': //drive
    if(Math.signum(ahrs.getYaw())==-1) {
    targetAngle=0;
    ahrs.reset();
    }
    if(toggle==0) {
    encoderStart=encLeft.getRaw();
    targetAngle=targetAngle-1;
    toggle=1;
    }
    else {
    if(encLeft.getRaw()*.013 < value) { //Flash and Vanellope have different definitions of right and left motors
    //This makes me frown so hard, I'm smiling again.
    //double drive=MAX_GOOD_SPEED*DIRECTION;
    //  drive = drive * value > 130 ? -3.66 : 1;
    driveTrain.tankDrive(Math.signum(value)*(-.3+DIRECTION*MAX_NOTHING_SPEED_LEFT)-(normalizeAngle(normalizeAngle(ahrs.getYaw())-normalizeAngle(targetAngle)))/12,Math.signum(value)*(-.3+DIRECTION*MAX_NOTHING_ANGLE_SPEED_RIGHT));
       
   
    }
    /*
    * if(enc.getDistance()-ancoderStart<value-ERROR)
    * {
    * double drive=MAX_GOOD_SPEED*DIRECTION;
      driveTrain.tankDrive(drive+DIRECTION*MAX_NOTHING_SPEED_LEFT,drive+DIRECTION*MAX_NOTHING_SPEED_RIGHT);
      double rate=enc.getRate()
      SmartDashboard.putNumber("Rate left", rate);
    * }
    */
    else {
    driveTrain.tankDrive(0, 0);
    commandRunner("r:0");
    return true;
    }
        }
    break;
    case 'm': // Drive according to encoder feedback
    if(toggle==0) {
    timeStart=timer.get();
    startAngle = ahrs.getYaw();
    //encoderStart=enc.getDistance();
    toggle=1;
    }
    else {
    if(encLeft.getDistance() < Math.abs(value)){
    double drive=MAX_GOOD_SPEED*DIRECTION;
    if(encLeft.getDistance()<BUFFER_DISTANCE) {
    driveTrain.tankDrive(
      DIRECTION*Math.signum(value)*(Math.abs(encLeft.getDistance())/BUFFER_DISTANCE*drive+MAX_NOTHING_SPEED_LEFT
      +Math.signum(startAngle-ahrs.getYaw())*(Math.abs(startAngle-ahrs.getYaw())<ERROR?.05:0))
      ,
      DIRECTION*Math.signum(value)*(Math.abs(encLeft.getDistance())/BUFFER_DISTANCE*drive+MAX_NOTHING_SPEED_RIGHT
      -Math.signum(startAngle-ahrs.getYaw())*(Math.abs(startAngle-ahrs.getYaw())>ERROR?.05:0)
      ));
    }
    else if(encLeft.getDistance()+BUFFER_DISTANCE<value) {
      driveTrain.tankDrive(
      Math.signum(value)*((drive+DIRECTION*MAX_NOTHING_SPEED_LEFT)
      +Math.signum(startAngle-ahrs.getYaw())*(Math.abs(startAngle-ahrs.getYaw())<ERROR?.05:0)),
      Math.signum(value)*((drive+DIRECTION*MAX_NOTHING_SPEED_RIGHT
      -Math.signum(startAngle-ahrs.getYaw())*(Math.abs(startAngle-ahrs.getYaw())>ERROR?.05:0))
      ));
      //driveTrain.tankDrive(Math.signum(value)*(drive+DIRECTION*MAX_NOTHING_SPEED_LEFT)+(Math.abs(startAngle-ahrs.getYaw())<ERROR?.05:0)/(startAngle-ahrs.getYaw()),Math.signum(value)*(drive+DIRECTION*MAX_NOTHING_SPEED_RIGHT+(Math.abs(startAngle-ahrs.getYaw())>ERROR?.05:0)));
    // Division is good between 20-15 Highscore Dante :23
    }
      else {
      driveTrain.tankDrive(
      DIRECTION*Math.signum(value)*(Math.abs(Math.abs(value)-encLeft.getDistance())/BUFFER_DISTANCE*drive+MAX_NOTHING_SPEED_LEFT
      +Math.signum(startAngle-ahrs.getYaw())*(Math.abs(startAngle-ahrs.getYaw())<ERROR?.05:0))
      ,
      DIRECTION*Math.signum(value)*(Math.abs(Math.abs(value)-encLeft.getDistance())/BUFFER_DISTANCE*drive+MAX_NOTHING_SPEED_RIGHT
      -Math.signum(startAngle-ahrs.getYaw())*(Math.abs(startAngle-ahrs.getYaw())>ERROR?.05:0)
      ));
     
      }
    }
    else {
    commandRunner("r:0");
    driveTrain.tankDrive(0,0);
    return true;
    }
        }
    break;
   
    case 't': //turn
    if(toggle==0) {
    angleStart=yaw;
    }
   
double angle=yaw-angleStart; //so angle is the amount that you have turned since starting this "t" case
double percentError=normalizeAngle(normalizeAngle(DIRECTION*value)-normalizeAngle(angle))/180; //percentError is how far off you are from your target
boolean maybe=(Math.abs(percentError*180)>ERROR||Math.abs(percentError2*180)>ERROR);
SmartDashboard.putNumber("angle", normalizeAngle(yaw+360-angleStart)); 
SmartDashboard.putNumber("Zero difference angle", angleStart); 
SmartDashboard.putBoolean("maybe", maybe);
if (toggle==1) {percentErrorPassCounter=percentErrorPassCounter+(Math.signum(percentError)!=Math.signum(percentError2)?1:0);}
SmartDashboard.putNumber("percentError", percentError*180);
SmartDashboard.putNumber("passed",percentErrorPassCounter);
double er=percentError/Math.pow(RETRY_PROPORTION, percentErrorPassCounter);
percentError2=percentError;
/*if (!turnController.isEnabled()) {
                turnController.setSetpoint(180);
                rotateToAngleRate = 0; // This value will be updated in the pidWrite() method.
                turnController.enable();
            }*/
            
            double leftStickValue = er*PROPORTION_LEFT;
            double rightStickValue = er*PROPORTION_RIGHT;
            SmartDashboard.putNumber("er", er);
if(percentErrorPassCounter<RETRY_ATTEMPTS||maybe||normalizeAngle(Math.abs(percentError-percentError)*180)>ERROR){
double driveLeft=DIRECTION*Math.signum(leftStickValue)*(Math.abs(leftStickValue)*MAX_GOOD_ANGLE_SPEED+MAX_NOTHING_ANGLE_SPEED_LEFT);
double driveRight=DIRECTION*Math.signum(rightStickValue)*(Math.abs(rightStickValue)*MAX_GOOD_ANGLE_SPEED+MAX_NOTHING_ANGLE_SPEED_RIGHT);
SmartDashboard.putNumber("driveLeft", driveLeft);
SmartDashboard.putNumber("driveRight", driveRight);
driveTrain.tankDrive(driveLeft,-driveRight); //***************** 3/15 note: if bot turns and never stops correcting/wiggling, make driveLeft negative and driveRight positive.
}
else { 
driveTrain.tankDrive(0,0);
commandRunner("r:0");
targetAngle=targetAngle+value;
return true;
}
toggle=1;
    break;
    }
    intakeBoth.set(g);
    return false;
    }
    
    public static double normalizeAngle(double angle){
    return angle-360*Math.round(angle/360.0);
    }
    
    
    public static int factorial(int value){
    if(value==0) {
    return 1;
    }
    return factorial(value-1)*value;
    }

  
    /**
     * This function is called periodically during autonomous
     */
    
    public void autonomousPeriodic() {
   
    System.out.println("--- autoperiodic");

        SmartDashboard.putNumber("Yaw", ahrs.getYaw());
        SmartDashboard.putNumber("Left Encoder Raw", encLeft.getRaw());
        SmartDashboard.putNumber("Right Encoder Raw", encRight.getRaw());
        SmartDashboard.putNumber("startAngle",startAngle);
        SmartDashboard.putNumber("Error", ahrs.getYaw() - startAngle);
        SmartDashboard.putNumber("Left Distance", encLeft.getDistance());
SmartDashboard.putNumber("Right Distance", encRight.getDistance());
SmartDashboard.putNumber("elevatorDestiny", elevatorDestiny);
SmartDashboard.putNumber("elevatorState", elevatorState);
SmartDashboard.putNumber("targetAngle", targetAngle);
String switchPos;
if(switchPosition=='L') {switchPos="L";}
else switchPos="R";
String scalePos;
if(scalePosition=='L') {scalePos="L";}
else scalePos="R";
SmartDashboard.putString("switchPos", switchPos);
SmartDashboard.putString("scalePos", scalePos);
distanceInchesL = encLeft.getRaw()*0.01363;
SmartDashboard.putNumber("distanceInchesL", distanceInchesL);
distanceInchesR = encRight.getRaw()*0.01363;
SmartDashboard.putNumber("distanceInchesR", distanceInchesR);
        ahrs.enableLogging(true);
        if(elevatorDestiny > elevatorState && elevatorTransition) { //drive up toward destination
elevator.set(1);
}
if(elevatorDestiny < elevatorState && elevatorTransition) { //drive down toward destination
elevator.set(-1);
}
elevatorState = limitSwitch0.get()? elevatorState:0; //if you trip switch 0, you're at ground level
    elevatorState = limitSwitch1.get()? elevatorState:2; //if you trip switch 1, you're at Switch level
    elevatorState = limitSwitch2.get()? elevatorState:4; //if you trip switch 2, you're at Low Scale level
   
        elevatorState = limitSwitch3.get()? elevatorState:6; //if you trip switch 3, you're at High Scale level
   

    SmartDashboard.putNumber("elevatorState", elevatorState);
   
   
   
    if(elevatorDestiny == elevatorState && elevatorTransition) { //stop when you get to the destination
    elevatorTimer.reset();
    elevatorTimer.start();
    elevator.set(0);
    elevatorTransition=false;
    }
    if((elevatorDestiny == elevatorState && elevatorState != 0) && !elevatorTransition) { //hold elevator steady against gravity
    if(elevatorTimer.get()>0.01 && elevatorTimer.get()<.4) {
    elevator.set(.1);
    }
    else {
    elevator.set(0);
    elevatorTimer.reset();
    elevatorTimer.start();
    }
    }
    else {
    elevatorTimer.reset();
    elevatorTimer.stop();
    }
        if (!done) {
        try {
    switch(startPosition) {
    case 'L': 
    if(destination == "Sw") {
    if(switchPosition == 'L') {
    i=i+(commandRunner(COMMANDLIST_L_SW_L[i])?1:0);
//     i=i+(commandRunner(COMMANDLIST[i])?1:0);
    }
    else {
    i=i+(commandRunner(COMMANDLIST_L_SW_R[i])?1:0);
//LScR
    }
    break;
    }
    if(destination == "Sc")
{
    if(scalePosition == 'L') {
    i=i+(commandRunner(COMMANDLIST_S_SC[i])?1:0);
    //LScL
    }
    else {
    i=i+(commandRunner(COMMANDLIST_D_SC[i])?1:0);
    //LScR
    }
    break;
    }
    case 'C': 
//     if(destination == "Sw") {
//     if(switchPosition == 'L') {
    i=i+(commandRunner(COMMANDLIST_C[i])?1:0);
    //CSw
//     }
//     else {
//     i=i+(commandRunner(COMMANDLIST_D_SC[i])?1:0);
//     //CSwR
//     }
    break;
//     }
   
    case 'R':if(destination == "Sw") {
    if(switchPosition == 'L') {
    i=i+(commandRunner(COMMANDLIST_R_SW_L[i])?1:0);
   
    //RSwL
    }
    else {
    //RSwR
    i=i+(commandRunner(COMMANDLIST_R_SW_R[i])?1:0);
   
    break;
    }
    if(destination == "Sc")
{
    if(scalePosition == 'L') {
    i=i+(commandRunner(COMMANDLIST_D_SC[i])?1:0);
    //RScL
    }
    else {
    i=i+(commandRunner(COMMANDLIST_S_SC[i])?1:0);
    //RScR
    }
    break;
    }
    }
   
    }
        }catch(IndexOutOfBoundsException r) {
        SmartDashboard.putBoolean("Commands Done", true);
done=true;
        }
        }
    }
    
     /**This function is called once each time the robot enters tele-operated mode*/
    
    public void teleopInit(){
    System.out.println("--- teleopinit");
//    c.setClosedLoopControl(false);
//    s0.set(true);
    timer.reset();
    timer.start();
    ahrs.resetDisplacement();
    elevatorState=0;
    elevatorDestiny=0;
    encLeft.reset();
    encRight.reset();
    adjustCube = false;
   
    }

    /**
     * This function is called periodically during operator control
     */
    
    // Two controllers can't input to the same things at the same time, gamepad 0 has priority
    public void teleopPeriodic() {
        System.out.println("--- teleopperiodic");
   
    SmartDashboard.putNumber("toggIntake1", toggIntake1);
    SmartDashboard.putNumber("toggIntake2", toggIntake2);
    SmartDashboard.putBoolean("confirmPath", confirmPath);
    SmartDashboard.putNumber("Left Distance", encLeft.getDistance());
    SmartDashboard.putNumber("Right Distance", encRight.getDistance());
    SmartDashboard.putBoolean("getRawButtonPressed", gamePad0.getRawButton(10));
    SmartDashboard.putBoolean("cToggCount", cToggCount);
    SmartDashboard.putBoolean("limitSwitch0", limitSwitch0.get());
    SmartDashboard.putNumber("Left Encoder Raw", encLeft.getRaw());
            SmartDashboard.putNumber("Right Encoder Raw", encRight.getRaw());
            //TESTING 1 2 3
            SmartDashboard.putNumber("elevator", elevator.get());
            SmartDashboard.putBoolean("confirmPath", confirmPath);
            SmartDashboard.putBoolean("limitSwitch0", limitSwitch0.get());
    SmartDashboard.putBoolean("limitSwitch1", limitSwitch1.get());
    SmartDashboard.putBoolean("limitSwitch2", limitSwitch2.get());
    SmartDashboard.putBoolean("limitSwitch3", limitSwitch3.get());
    SmartDashboard.putNumber("elevatorState", elevatorState);
    SmartDashboard.putNumber("elevatorDestiny", elevatorDestiny);
            
            
            distanceInchesL = encLeft.getRaw()*0.013;
    SmartDashboard.putNumber("distanceInchesL", distanceInchesL);
    distanceInchesR = encRight.getRaw()*0.013;
    SmartDashboard.putNumber("distanceInchesR", distanceInchesR);
    if(timer.get()>=105) {rgbLights.set(.15);}
    //SisterBot Code
    double rightStick = (gamePad0.getRawAxis(5) *.6)*(gamePad0.getRawAxis(3)+1);      //Drive Controls
    double leftStick = (gamePad0.getRawAxis(1) *.6)*(gamePad0.getRawAxis(3)+1); 
    SmartDashboard.putNumber("leftStick",leftStick);
    SmartDashboard.putNumber("rightStick",rightStick);
    driveTrain.tankDrive(rightStick,leftStick); //rightStick, leftStick : Vanellope
    //
   
   
    /* CompetitionBot Code
    double leftStick = (-gamePad0.getRawAxis(1) *.5)*(gamePad0.getRawAxis(3)+1); 
    double rightStick = (-gamePad0.getRawAxis(5) *.5)*(gamePad0.getRawAxis(3)+1); 
    driveTrain.tankDrive(DIRECTION*leftStick,DIRECTION*rightStick);
    */
   
    //Climber
   
    if(gamePad0.getPOV() == 90) {
    adjustCube = true;
    intakeRight.set(.2);
    intakeLeft.set(-.2);
    }
   
    if(gamePad0.getPOV() == 270) {
    adjustCube = true;
    intakeLeft.set(.2);
    intakeRight.set(-.2);
    }
    /*
    if(gamePad0.getRawButton(5) && toggIntake1 == 0) {//Intake
    /*if(intakeBoth.get()!=-.5) {intakeBoth.set(-.5); toggIntake2 = 0;} CompetitionBot                FIX
     
    if(intakeBoth.get()!=.5) {intakeBoth.set(.5); toggIntake2 = 0;} //SisterBot
    else {intakeBoth.set(0); confirmPath = true;}
    toggIntake1++;
    }
    if(!gamePad0.getRawButton(5) && toggIntake1 == 1) {
    toggIntake1 = 0;
   
   
   
    }//End of Intake
    */
   
    if(gamePad0.getRawButton(5) && toggIntake2 == 0) {//Input
   
    if(intakeBoth.get()==0) {intakeBoth.set(.5); toggIntake1 = 0;} // .5 for CompBot
    else intakeBoth.set(0);
    toggIntake2++;
   
    }
    if(!gamePad0.getRawButton(5) && toggIntake2 == 1) {
    toggIntake2 = 0;
    }//End of Output
   
    if(gamePad0.getRawButton(6) && toggIntake1 == 0) {//Output
    if(intakeBoth.get()==0) {intakeBoth.set(-1); toggIntake2 = 0;} // .5 for CompBot
    else intakeBoth.set(0);
    toggIntake1++;
    }
    if(!gamePad0.getRawButton(6) && toggIntake1 == 1) {
    toggIntake1 = 0;
    }
   
    //ELEVATOR
    if(gamePad0.getPOV()==0) {
    elevatorMode = "manual";
    //intakeBoth.set(0);
    elevatorTransition=true;
    elevator.set(elevatorState == 6 ? 0 : .5);
    elevatorDestiny = elevatorState;
    }
    if(gamePad0.getPOV()==180) {
    elevatorMode = "manual";
    elevatorTransition=true;
    elevator.set(elevatorState == 0 ? 0 : -.5);
    elevatorDestiny = elevatorState;
    }
    if(gamePad0.getPOV()==-1) {
    elevatorMode = "automatic";
    if(adjustCube) {
    intakeRight.set(0);
    intakeLeft.set(0);
    adjustCube=false;
    }
    }
   
    //Climber
   
    /*if(gamePad0.getRawButtonPressed(7)) {
    cToggCount = !cToggCount;
    //climbLift.set(cToggCount ? 1 : 0); //does getRawButtonPressed just hate ternary?
    }
    if(cToggCount) {
    climbLift.set(1);
    }
    */
    if(gamePad0.getRawButtonPressed(7)) {
    cToggCount=!cToggCount;
    if(cToggCount) {
    climbLift.set(1);
    }
    else climbLift.set(0); //getRawButtonPressed works
    }
    /*if(gamePad0.getRawButtonPressed(8)) {
    cToggCount1 = !cToggCount1;
    }
    if(cToggCount1) {
    climber.set(.75);
    climbLift.set(-1);
    }
    */
    if(gamePad0.getRawButtonPressed(8)) {
    cToggCount1=!cToggCount1;
    if(cToggCount1) {
    climber.set(.75);
    climbLift.set(-1);
    }
    else climber.set(0); climbLift.set(0);
    }
    /*
    if(gamePad0.getRawButtonPressed(9)) { //for practice only. unwinds strap
    cToggCount2 = !cToggCount2;
    }
    if(cToggCount2) {
    climber.set(-.5);
    }
    */
    if(limitSwitch5.get()==false) {
    climber.set(0);
    }
    if(limitSwitch4.get()==false) {
    climbLift.set(0);
    }
    if(!gamePad0.getRawButton(5) && toggCount2 == 1) {
      toggCount2 = 0;
    }
      
//     if(gamePad0.getRawButton(6) && toggCount == 0) {
//     s0.set(!s0.get());//S0 doesn't work without S2 going at the same time?
//     s1.set(!s1.get());// Gear pneumatics
//     s2.set(!s2.get());//
//     toggCount++;
//     }
    if(!gamePad0.getRawButton(6) && toggCount == 1) {
    toggCount = 0;
    }
   
   
   
   
   
   
    //BELOW ARE ELEVATOR CONTROLS
    //limit switches
   
    //elevator code
    elevatorState = limitSwitch0.get()? elevatorState:0; //if you trip switch 0, you're at ground level
    elevatorState = limitSwitch1.get()? elevatorState:2; //if you trip switch 1, you're at Switch level
    elevatorState = limitSwitch2.get()? elevatorState:4; //if you trip switch 2, you're at Low Scale level
   
        elevatorState = limitSwitch3.get()? elevatorState:6; //if you trip switch 3, you're at High Scale level
    if((elevator.get()-.1 > 0 && elevatorState == 4 && limitSwitch2.get())||(elevator.get() < 0 && elevatorState == 6 && limitSwitch3.get())/*||(elevatorState == 6 && limitSwitch3.get()==false)*/) { //if you are going up from switch 2 or coming down from switch 3, youâ€™re in between 2 and 3
    elevatorState = 5;
    }
    if((elevator.get()-.1 > 0 && elevatorState == 2 && limitSwitch1.get())||(elevator.get() < 0 && elevatorState == 4 && limitSwitch2.get())/*||(elevatorState == 4 && limitSwitch2.get()==true)*/) { //if you are going up from switch 1 or coming down from switch 2, youâ€™re in between 1 and 2 
    elevatorState = 3;
    }
    if((elevator.get()-.1 > 0 && elevatorState == 0 && limitSwitch0.get())||(elevator.get() < 0 && elevatorState == 2 && limitSwitch1.get())/*||(elevatorState == 2 && limitSwitch1.get()==true)*/) { //if you are going up from switch 0 or coming down from switch 1, youâ€™re in between 0 and 2
    elevatorState = 1;
    confirmPath = true;
    }
   
    //Flip the polarity of comparators
   
   
    if(gamePad0.getRawButtonPressed(1)) { //Press A to call elevator to ground level
    elevatorMode = "automatic";
    elevatorDestiny = 0;
    elevatorTransition=true;
    }
    if(gamePad0.getRawButtonPressed(2)) { //Press B to call elevator to Switch Level
    elevatorMode = "automatic";
    elevatorDestiny = 2;
    elevatorTransition=true;
    }
    if(gamePad0.getRawButtonPressed(3)) { //Press X to call elevator to low scale
    elevatorMode = "automatic";
    elevatorDestiny = 4;
    elevatorTransition=true;
    }
    if(gamePad0.getRawButtonPressed(4)) { //Press Y to call elevator to high scale
    elevatorMode = "automatic";
    elevatorDestiny = 6;
    elevatorTransition=true;
   
    }
   
    if (elevatorMode == "automatic") {
    if(elevatorDestiny > elevatorState) { //drive up toward destination
    elevator.set(1);
    }
    if(elevatorDestiny < elevatorState) { //drive down toward destination
    elevator.set(-1);
    }
    }





    if(elevatorDestiny == elevatorState && elevatorMode == "automatic" && elevatorTransition) { //stop when you get to the destination
    elevatorTimer.reset();
    elevatorTimer.start();
    elevator.set(0);
    elevatorTransition=false;
    }
    
    boolean bouncy=false;
    if((elevatorDestiny == elevatorState && elevatorState != 0) && elevatorMode == "automatic"&&!elevatorTransition) { //hold elevator steady against gravity
    if(elevatorTimer.get()>0.01 && elevatorTimer.get()<.4) {
    elevator.set(.1);
    }
    else {
    elevator.set(0);
    elevatorTimer.reset();
    elevatorTimer.start();
    }
    bouncy=true;
    }
    else {
    elevatorTimer.reset();
    elevatorTimer.stop();
    }
    }
   
   
   
   
   
    public static void main (String[] args) {
              Robot.main(args);
        }

}

   
    /**
     * This function is called periodically during test mode
     */
